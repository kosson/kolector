{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./public/js/main.mjs"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,IAAI;;AAEJ;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oFAAoF","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./public/js/main.mjs\");\n","var uuid = '', csrfToken = '';\r\n\r\nif(document.getElementsByName('_csrf')[0].value) {\r\n    csrfToken = document.getElementsByName('_csrf')[0].value;\r\n}\r\n\r\nvar pubComm = io('/redcol', {\r\n    // path: '/socket.io', \r\n    allowUpgrades: true, \r\n    transports: ['polling', 'websocket'], \r\n    httpCompression: true,\r\n    cookieHttpOnly: true,\r\n    query: {['_csrf']: csrfToken}\r\n});\r\n\r\n// === MANAGEMENTUL COMUNICĂRII pe socketuri ===\r\n// pubComm.on('mesaje', (mess) => {\r\n//     // TODO: execută funcție care afișează mesajul\r\n\r\n//     $.toast({\r\n//         heading: 'Colectorul spune:',\r\n//         text: `${mess}`,\r\n//         position: 'top-center',\r\n//         showHideTransition: 'fade',\r\n//         hideAfter : 7000,\r\n//         icon: 'info'\r\n//     });\r\n//     //https://kamranahmed.info/toast\r\n// });\r\n\r\n/**\r\n * Clasa `createElement` va creea elemente HTML\r\n * @param {string} tag este un șir de caractere care indică ce tip de element va fi creat\r\n * @param {string} [id] este un șir de caractere care indică un id pentru element\r\n * @param {Array}  [cls] este un array ce cuprinde clasele elementului\r\n * @param {Object} [attrs] este un obiect de configurare a elementului care permite definirea de atribute\r\n */\r\nclass createElement {\r\n    constructor(tag, id, cls, attrs){\r\n        this.id = id;\r\n        this.tag = tag;\r\n        this.classes = [...cls];\r\n        this.attributes = attrs;    // va fi un un obiect de configurare, fiecare membru fiind un posibil atribut.\r\n    }\r\n    /**\r\n     * Metoda `creeazaElem()` generează obiectul DOM\r\n     * @param {String} textContent Este conținutul de text al elementului, dacă acest lucru este necesar\r\n     * @param {Boolean} requiredElem Specifică dacă un element are atributul `required`\r\n     */\r\n    creeazaElem (textContent, requiredElem) {\r\n        const element = document.createElement(this.tag);\r\n        if (this.id) element.id = this.id;\r\n        if (this.classes) element.classList.add(...this.classes);\r\n        if (this.attributes) {\r\n            for (let [key, val] of Object.entries(this.attributes)) {\r\n                element.setAttribute(key, val);\r\n            }\r\n        }\r\n        // if (textContent) element.textContent = textContent;\r\n        if (textContent) {\r\n            var text = '' + textContent;\r\n            let encodedStr = decodeCharEntities(text); // decodifică entitățile \r\n            let txtN = document.createTextNode(encodedStr);\r\n            element.appendChild(txtN);\r\n        }\r\n        if (requiredElem) element.required = true;\r\n        return element;\r\n    }\r\n}\r\n\r\n/**\r\n * Convertește un characterSet html în caracterul original.\r\n * @param {String} str htmlSet entities\r\n **/\r\nfunction decodeCharEntities (str) {\r\n    let decomposedStr = str.split(' ');\r\n    // FIXME: Nu acoperă toate posibilele cazuri!!! ar trebui revizuit la un moment dat.\r\n    var entity = /&(?:#x[a-f0-9]+|#[0-9]+|[a-z0-9]+);?/igu;\r\n    \r\n    let arrNew = decomposedStr.map(function (word, index, arr) {\r\n        let newArr = [];\r\n        if (word.match(entity)) {\r\n            let fragment = [...word.match(entity)];\r\n\r\n            for (let ent of fragment) {\r\n                var translate_re = /&(nbsp|amp|quot|lt|gt);/g;\r\n                var translate = {\r\n                    \"nbsp\" : \" \",\r\n                    \"amp\"  : \"&\",\r\n                    \"quot\" : \"\\\"\",\r\n                    \"apos\" : \"\\'\",\r\n                    \"cent\" : \"¢\",\r\n                    \"pound\": \"£\",\r\n                    \"yen\"  : \"¥\",\r\n                    \"euro\" : \"€\",\r\n                    \"copy\" : \"©\",\r\n                    \"reg\"  : \"®\",\r\n                    \"lt\"   : \"<\",\r\n                    \"gt\"   : \">\"\r\n                };\r\n                return ent.replace(translate_re, function (match, entity) {\r\n                    return translate[entity];\r\n                }).replace(/&#(\\d+);/gi, function (match, numStr) {\r\n                    var num = parseInt(numStr, 10);\r\n                    return String.fromCharCode(num);\r\n                });\r\n            }\r\n            return arrNew;\r\n        } else {\r\n            newArr.push(word);\r\n        }\r\n        return newArr.join('');\r\n    });\r\n    return arrNew.join(' ');\r\n};\r\n/**\r\n * Funcția are rolul de a extrage setul de date atașat unui element prin data-*\r\n * @param {Object} elem \r\n */\r\nfunction datasetToObject(elem){\r\n    var data = {};\r\n    [].forEach.call(elem.attributes, function(attr) {\r\n        if (/^data-/.test(attr.name)) {\r\n            var camelCaseName = attr.name.substr(5).replace(/-(.)/g, function ($0, $1) {\r\n                return $1.toUpperCase();\r\n            });\r\n            data[camelCaseName] = attr.value;\r\n        }\r\n    });\r\n    return data;\r\n};\r\n\r\nexport const main = {\r\n    uuid: uuid,\r\n    csrfToken: csrfToken,\r\n    pubComm: pubComm,\r\n    createElement: createElement,\r\n    decodeCharEntities: decodeCharEntities,\r\n    datasetToObject: datasetToObject\r\n};\r\n\r\n// document.addEventListener(\"DOMContentLoaded\", function clbkDOMContentLoaded () {});\r\n\r\n"],"sourceRoot":""}